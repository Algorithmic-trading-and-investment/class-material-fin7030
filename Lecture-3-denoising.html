<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Algorithmic trading and investment</title>
    <meta charset="utf-8" />
    <meta name="author" content="Barry Quinn" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/xaringanExtra-webcam/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <link rel="stylesheet" href="css/fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/sfah.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




layout: true

&lt;div class="my-footer"&gt;&lt;span&gt;quinference.com&lt;/span&gt;&lt;/div&gt;

<div>
<style type="text/css">.xaringan-extra-logo {
width: 110px;
height: 128px;
z-index: 0;
background-image: url(img/redlogo.png);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
top:1em;right:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>

---
name: ATL-title
class: inverse,left, middle
background-image: url(img/title-slide-img.png)
background-size: cover

# Algorithmic Trading and Investing (FIN7030)

# .fancy[Lecture 3: Extracting signal from noisy data]

.large[Barry Quinn PhD CStat | Queen's Management School | 2021-02-07]

&lt;!-- this ends up being the title slide since seal = FALSE--&gt;

---
class:inverse
# Learning outcomes 
- .large[Growth learning of mathematics]
- .large[The Jewel of the Matrix: Eigenvalues and Eigenvectors]
- .large.fancy[Mining the Jewel]
- .large[Random Matrix Theory technique: **Marcenko-Pastur Theorem**]
- .large[Denoising financial covariance matrices]
- .heat[Real world application for investment algorithms]
---
class: inverse
## Teaching mathematical concepts

.heatinline[
- Understanding machine learning requires familiarity with many mathematical concepts

- The goal of this course is to build your intuition about these notions without getting overly technical

- In particular restricting explanations to mathematical notation can be off-putting.

- Instead we will visual concepts through code, conversation and real-world applications

- Learning concepts via a multidimensional approach creates permanent brain connects and lasting learning.

- Mostly, we will use coded practical example to illustrate the concepts]

.salt[ This is a .large.fancy[**learning by doing**] approach when you can play around with the code making mistakes and build permanent learning]

---
class: middle
# Why study denoising and detoning?

- .large[Covariance matrices are everywhere in finance]
- .large[Empirical covariances measure the linear co-movement between a set of random variables]  
- .large[For example to estimate the linear comovement between FTSE 100 stocks you would gather 100 time series of each stocks returns]
- .large[They are used to:]

1. Run regressions
2. Estimate risk
3. **Optimise portfolios**
4. Simulate scenarios via Monte Carlo
5. Find clusters
6. Reduce the dimensionality of a set of potential predictors

---
class:middle
# Eigen.....
## The story of the billion dollar eigenvector

- .heatinline[Larry page and Sergy Bin built a  dollar company based on solving a linear alegbra problem using eigenvectors]
- In the following clip, Professor Steve Strogatz tells the story of the eigenvector, and its billion dollar application in Google.


&lt;iframe height="300", width="500" scrolling="no" frameborder="yes" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/302257938&amp;color=%23d0aca4&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;show_teaser=true&amp;visual=true"&gt;&lt;/iframe&gt;&lt;div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;"&gt;&lt;a href="https://soundcloud.com/edwardoneill" title="edwardoneill" target="_blank" style="color: #cccccc; text-decoration: none;"&gt;edwardoneill&lt;/a&gt; ¬∑ &lt;a href="https://soundcloud.com/edwardoneill/steven-strogatz-on-teaching-eigenvectors-and-eigenvalues" title="Steven Strogatz on Teaching Eigenvectors and Eigenvalues" target="_blank" style="color: #cccccc; text-decoration: none;"&gt;Steven Strogatz on Teaching Eigenvectors and Eigenvalues&lt;/a&gt;&lt;/div&gt;

---
class:middle
## The &lt;svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 576 512"&gt;&lt;path d="M485.5 0L576 160H474.9L405.7 0h79.8zm-128 0l69.2 160H149.3L218.5 0h139zm-267 0h79.8l-69.2 160H0L90.5 0zM0 192h100.7l123 251.7c1.5 3.1-2.7 5.9-5 3.3L0 192zm148.2 0h279.6l-137 318.2c-1 2.4-4.5 2.4-5.5 0L148.2 192zm204.1 251.7l123-251.7H576L357.3 446.9c-2.3 2.7-6.5-.1-5-3.2z"/&gt;&lt;/svg&gt; of financial matrices: *Eigenvalues* and *eigenVectors*

- As discussed, the financial world is increasing becoming defined by *Big Data*, and data-driven decision making.

--

- As everything becomes defined by data, they are stored in matrices

--

- Success in the rapidly evolving quant finance industry increasing requires creative analytics and communications of complex and complication matrix-stored data.

--

- At the center of the matrix, through the complexities, lie its &lt;svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 576 512"&gt;&lt;path d="M485.5 0L576 160H474.9L405.7 0h79.8zm-128 0l69.2 160H149.3L218.5 0h139zm-267 0h79.8l-69.2 160H0L90.5 0zM0 192h100.7l123 251.7c1.5 3.1-2.7 5.9-5 3.3L0 192zm148.2 0h279.6l-137 318.2c-1 2.4-4.5 2.4-5.5 0L148.2 192zm204.1 251.7l123-251.7H576L357.3 446.9c-2.3 2.7-6.5-.1-5-3.2z"/&gt;&lt;/svg&gt; the eigenvector and eignenvalues.

--

- The provide clarity and the true signal in the noisy data.

--

- Understand what they are is vital to be successful in modern finance. 

---
class:middle
# Deep dive: What is a matrix?
..pull-left[
![](img/vectors.png)
]
.pull-right.large[
- One of the simplest matrix forms is a two-dimensional vector.
- It has two elements which each correspond to one coordinate on the two-dimensional plane.
-  For example each of the following vectors represent a movement on the y and x planes 
]

---
class:middle
# Deep dive: Matrix are linear transformers
.pull-left[
![](img/lineartransform.png)
]
.pull-right[
- In the matrix world, a linear transformation is performed by multiplying a vector by a matrix.
- Visually, the effect is to stretch (or squish) the coordinate system along two vectors
- For example the linear transformation matrix `\(\begin{bmatrix} 3 &amp; 1 \\ 1 &amp; 2 \end{bmatrix}\)` aligns the x-axis along the vector `\(\begin{bmatrix} 3&amp;1 \end{bmatrix}\)` (the first column) and the y-axis along the vector `\(\begin{bmatrix} 1&amp;2 \end{bmatrix}\)`

- .heatinline[The red lines show the transformation aligned to the y-axis]
- .saltinline[The blue lines show the transformation aligned to the x-axis]
]

---
middle:class
## Deep dive: What are eigenvectors and eigenvalues?
.pull-left[
![](img/lineartransform2.png)
]

.pull-right[
- Consider the vector  `\(\begin{bmatrix} -1&amp;-1 \end{bmatrix}\)` in the below figure
- After it is multiplied by the linear transformation matrix, it lands on the point `\(\begin{bmatrix} -4&amp;-3 \end{bmatrix}\)`
- .saltinline[A vector's span is the line that runs through the vector forever]
- .saltinline[When a vector undergoes a linear transformation usually it is knocked off of its span]
- .bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt5[
*Eigenvectors* are vectors that do not get knocked off their span.  Instead, when eigenvectors are multiplied by a matrix, the eigenvector is simply scaled by a factor of the *eigenvalue*, landing somewhere else along the span
]
]

---
class:middle
# Deep dive: Eigenvectors explained
.pull-left[
![](img/eigenvector_messy.png)
 - Eigenvectors and eigenvalues are seldom whole numbers and challenging to calculate with accuracy
]
.pull-right[
- The nature of eigenvectors means that scaling an *Original* eigenvector in the same or directly opposite direction will yield yet another *scaled* eigenvector
![](img/eigenvector_scale.png)
]

---
class:top,left
# Deep dive: The world in 3-dimensions
.pull-left[
- In 3-D, the matrix describes a transformation of 3 axes, x, y and z, corresponding to the three coordinates that represent the transformation each coordinate undergoes.
- For this reason, *eigenvectors* and *eigenvalues* are only defined for square matrices
![](img/3x3sqmatrix.png)
]
.pull-right[
- In order to find the eigenvector of a matrix, we need to find the eigenvalue
- From the definition of the eigenvalue, we can construct an equality `\(Ax=\lambda x\)`, where `\(A\)` represents the matrix and `\(\lambda\)` represents the eigenvalue.

.saltinline[The logic of this equality is that multiplying the eigenvector by the transformation matrix `\(x\)` should have the same effect as scaling it by eigenvalue `\(\lambda\)`]
]
.footnote.mid-gray[A square matrix is a general `\(n\)` by `\(n\)` matrix describing the transformation of `\(n\)` axes, each corresponding to a coordinate with `\(n\)` elements]
---
class:top
## Deep dive: Calculating the eigenvector and eigenvalue
.pull-left[
![](img/matrixalgebra.png)

]
.pull-right[
- Rearrange the equality to make all terms on the right side (A is a matrix and `\(\lambda\)` is a number so we have to an identity matrix `\(I\)` which applies no transformation at all) to find a solution fo the eigenvalue.

- As the previous plot shows, there are infinite number of *trivial solutions*, or solutions that can be achieved simply by scaling an eigenvector by any number.

- In order to get rid of trivial solutions, we use the .red[determinant].
]
---
class:middle
## Deep dive: What is a determinant?
&lt;div class="figure" style="text-align: left"&gt;
&lt;img src="img/squareunit.png" alt="Figure 1" width="50%" /&gt;
&lt;p class="caption"&gt;Figure 1&lt;/p&gt;
&lt;/div&gt;

&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="img/4squnits.png" alt="Figure 1" width="50%" /&gt;
&lt;p class="caption"&gt;Figure 1&lt;/p&gt;
&lt;/div&gt;

- The .red[determinant] is a measure of the factor in which area is stretched by a transformation matrix.

- Figure 1 shows one standard square on the coordinate space, with an area of one square unit.

- When the space is stretched `\(\begin{bmatrix} 2&amp;1\\0 &amp;2\end{bmatrix}\)` , the new area is four square units

- **Because the area increases by a factor of four, the determinant of the matrix is four**
---
background-image: url(https://raw.githubusercontent.com/barryquinn1/quinnference_website/master/content/authors/admin/avatar.jpeg)
---
class:middle
## Deep dive: What is the determinant is zero?
![](img/det.png)
- When the determinant is zero, the area of the square is collapsed to zero, meaning that the two vectors describing the locations of the axes are on the same line.

- .heatinline[when the determinant equals zero all of space is warped into one single line (one-dimensional)]

.heat[Therefore to make the previous equality easily solvable (by discarding the space of redundant or trivial solutions) it must be true that the determinant of the matrix must be equal to zero]

---
background-image: url(https://raw.githubusercontent.com/barryquinn1/quinnference_website/master/content/authors/admin/avatar.jpeg)
---
class:middle
## Deep dive: Get ready for the math! 
.left-column[
üòï
]
.right-column[
&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="img/detcalc.png" alt="Figure 3" width="50%" /&gt;
&lt;p class="caption"&gt;Figure 3&lt;/p&gt;
&lt;/div&gt;
- In 2-D finding the eigenvalue is then a task of solving a quadratic

- Figure 3 shows that the eigenvalues of the matrix `\(\begin{bmatrix}1&amp;4\\3&amp;2\end{bmatrix}\)` are 5 and -2

- This means that when the eigenvectors of the matrix are multiplied by the matrix, their vector length will be stretched by a factor of 5 and -2, respective to each of the eigenvectors
]

.footnote.red[ For three or more dimension matrix, a different form of the determinant formula must be used]

---
class:middle
## Deep dive: Even more math!
.left-column[
üòï
]
.right-column[
&lt;div class="figure" style="text-align: right"&gt;
&lt;img src="img/detcalc1.png" alt="Figure 4" width="50%" /&gt;
&lt;p class="caption"&gt;Figure 4&lt;/p&gt;
&lt;/div&gt;
- By plugging in the discovered eigenvalues into our originally derived equation, we find the eigenvectors
- In the case of the calculation in figure 4, when we plug in `\(\lambda=5\)` we get `\(x=\begin{bmatrix}1\\1\end{bmatrix}\)`
- When we plug in when we plug in `\(\lambda=-2\)` we get `\(x=\begin{bmatrix}-4\\3\end{bmatrix}\)`

.heatinline.bold[Given only the eigenvectors and eigenvalues of any matrix, one can easily completely reconstruct the original matrix]

.saltinline.bold[This special property guarantees that eigenvectors will show up in almost all financial data science problems]

]
---
class:middle
## Deep dive: Machine learning and eigenvectors
- Principal component analysis (PCA) is a common unsupervised machine learning technique that seeks to reduce the dimensionality of data whilst retaining key statistical measures like variance and mean.

- Consider a financial data set with 100 features (100-Dimensions), we can attempt to reduce this to 2-D using PCA.

-Firstly, the algorithm constructs the covariance matrix, which evaluates (in a sense) how correlated two variables are.

- The full covariance matrix defines the **shape** of the data

.footnote[We see come across this **shape** concept again when we using code.]

---
class:middle
## Deep dive: Machine learning and eigenvectors

- Eigenvectors of the covariance matrix are used to reorient the data among the x and y axes along lines of the great variance.

- Eigenvectors facilities a snapshot of the matrix, which tells the algorithm which areas to amplify and which to mute.

- Countless other applications of eigenvectors and eigenvalues, from machine learning to topology, utilise the key feature that eigenvectors provide so much useful information about a matrix.

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt5[Perhaps the reason why eigenvectors and eigenvalues are so special is because of its definition : *the vectors whose direction remains unchanged whilst space around them is warped, pointing forever through the complexity at the true beauty of the matrix* 

&lt;footer&gt;Andre Ye 2020&lt;/footer&gt;
]


---
class: middle,center
background-image: url(img/title-slide-img.png)
background-size: cover
# Learning through growth headspace

.fat.center[Focus excercise](https://my.headspace.com/play/1257)

---
class: middle 
# Why study denoising?

.large[

- Empirical covariance matrices are estimated with flawed, incomplete data which leads to estimates with an amount of noise

- Such noise can render calculations using covariance matrix estimates useless

- In finance, we need a procedure to reduce this noise and enhance the signal **before** using in subsequent analysis like those listed previously
]

---
class: middle
# Denoising using Random Matrix Theory
- This is an elegant mathematical theorem that can help *denoise* data by distinguishing random from non-random from nonrandom by means of the empirical correlation matrix of the data.

- The probability density function (pdf) of a Marcenko-Pastur distribution produces a set of eigenvalues which are randomly distributed.

- We can exploit this property to extract the non-random component of some empirical correlation matrix, thus removing the random noise.

.heat.fancy[Our goal is to learn how to discriminate between eigenvalues associated with noise components and eigenvalues associated with signal components]

---
class:middle
## Application to finance

- Sophisticated optimal liquidation portfolio algorithms that balance risk against impact cost involve inverting the covariance matrix of the portfolio.

- Eigenvalues of the covariance matrix that are small (or even zero) correspond to portfolios of stocks that have nonzero returns but extremely low or vanishing risk.

.heatinline[Such portfolios are invariably related to estimation errors resulting from insufficient data]

.fatinline[One of the approaches used to eliminate the problem of small eigenvalues in the estimated covariance matrix is the so-called **random matrix** technique]

---
class:middle
# Random correlation matrices

- Suppose we have `\(M\)` stock returns series with `\(T\)` elements each.  The elements of the `\(M \times M\)` empirical correlation matrix `\(E\)` are given by 

`$$E_{ij}=\frac{1}{T} \sum_t^T x_{it}x_{jt}$$`
- where `\(x_{it}\)` denotes the t^th return of the stock *i*, normalised by the standard deviation so that `\(Var[x_{it}]=1\)`

- In matrix form we can rewrite the above as:

`$$\bf{E=HH^{'}}$$`
- where `\(\bf{H}\)` is the `\(M \times T\)` matrix whose rows are the time series of returns, one for each stock.

---
class:middle
# Eigenvalue spectrum of random correlation matrix

- Suppose the entries of the **H** are random with variance `\(\sigma^2\)`.

- Then in the limit `\(T,M \rightarrow \infty\)` keep the ratio `\(Q:=T/M \ge 1\)` constant, the density of the eigenvalues of **E** is given by:

`$$\rho\left(\lambda  \right) = 
    \begin{cases} 
      \frac{T}{N}\frac{\sqrt {\left( {{\lambda _{+}} - \lambda} \right)\left( {\lambda  - {\lambda _{- }}} \right)}}{2\pi \lambda {\sigma ^2}}, &amp; \text{if } \lambda \in [\lambda _{+},\lambda _{-}] \\
      0, &amp; \text{if } \lambda \notin [\lambda _{+},\lambda _{-}]
     \end{cases}$$`

- where the maximum expected eigenvalue is `\(\lambda_{+}=\sigma^2(1+\sqrt{N/T})^2\)` and the minimum expected eigenvalue is  `\(\lambda_{-}=\sigma^2(1-\sqrt{N/T})^2\)`

---
class:middle
# Example: Independent and identically distributed random normal returns

.panelset[
.panel[
.panel-name[Set-up with some fake data]
- Let X be a matrix of 1000 (m=1000) stock return series for 5000 days (t=5000) and assume that these returns are distributed as random normal observations

```r
t &lt;- 5000
m &lt;- 1000
h &lt;- array(rnorm(m*t),c(m,t)) # time series in rows
e &lt;- h %*% t(h)/t # form the correlation matrix
lambda_e &lt;- eigen(e,symmetric = T, only.values = T)
ee &lt;- lambda_e$values # Eigenvalyes if the correlation matrix
```

]
.panel[
.panel-name[Function to compute Marcenko-Pastur density in &lt;svg style="height:0.8em;top:.04em;position:relative;" viewBox="0 0 581 512"&gt;&lt;path d="M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z"/&gt;&lt;/svg&gt;]



```r
library(matlab)
# This function takes 3 arguments and returns the Marcenko-Pastur probability density function
mp_pdf&lt;-function(var,t,m,pts) {
  q=t/m
  eMin&lt;-var*(1-(1./q)^.5)^2 
  eMax&lt;-var*(1+(1./q)^.5)^2 
  eVal&lt;-linspace(eMin,eMax,pts)
  pdf&lt;-q/(2*pi*var*eVal)*((eMax-eVal)*(eVal-eMin))^.5
  pdf&lt;-array(pdf) 
  names(pdf)&lt;-eVal # creates a named array
  return(pdf)  
}
```

.heatinline[The eigenvectors represent the principal components of the matrix, while the eigenvalues are used to find the proportion of the total variance explained by the components]

]
.panel
[.panel-name[Test the theorem]

```r
pdf0=mp_pdf(1,t=t,m=m,pts=N) # Marcenko-Pastur pdf
pdf1=density(ee,width=0.01,kernel = "gaussian") # empirical pdf
```
]
.panel[.panel-name[Visualising Marcenko-Pastur theorem]
![](Lecture-3-denoising-and-detoning_in_Rcode_files/figure-html/visualise-mp-1.png)&lt;!-- --&gt;
]
.panel[
.panel-name[Smaller sample]
![](Lecture-3-denoising-and-detoning_in_Rcode_files/figure-html/visualisemp2-1.png)&lt;!-- --&gt;
]
.panel[
.panel-name[Even smaller sample]
![](Lecture-3-denoising-and-detoning_in_Rcode_files/figure-html/visualisemp3-1.png)&lt;!-- --&gt;
.heat[We see that even for rather small matrices, the theoretical limiting density approximates the actual density pretty well]

]
]
---
background-image: url(https://raw.githubusercontent.com/barryquinn1/quinnference_website/master/content/authors/admin/avatar.jpeg)
---
class:middle
# An experiment with real data

.panelset[
.panel[
.panel-name[Load Dow-Jones 30 returns data and examine]
To demonstrate the use of Random Matrix theory we will choose the `\(\texttt{dow30data}\)` object which contains daily returns for ow Jones 30 index for a year.


```r
load("dow30data.RData")
skimr::skim(dow30data) # an informative overview of the data
```


Table: Data summary

|                         |          |
|:------------------------|:---------|
|Name                     |dow30data |
|Number of rows           |321       |
|Number of columns        |30        |
|_______________________  |          |
|Column type frequency:   |          |
|numeric                  |30        |
|________________________ |          |
|Group variables          |None      |


**Variable type: numeric**

|skim_variable | n_missing| complete_rate| mean|   sd|    p0|   p25| p50|  p75| p100|hist  |
|:-------------|---------:|-------------:|----:|----:|-----:|-----:|---:|----:|----:|:-----|
|AAPL          |         0|             1| 0.01| 0.11| -0.04| -0.01|   0| 0.01| 1.96|‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ |
|AXP           |         0|             1| 0.00| 0.01| -0.07| -0.01|   0| 0.01| 0.03|‚ñÅ‚ñÅ‚ñÇ‚ñá‚ñÇ |
|BA            |         0|             1| 0.00| 0.01| -0.05| -0.01|   0| 0.01| 0.06|‚ñÅ‚ñÉ‚ñá‚ñÅ‚ñÅ |
|CAT           |         0|             1| 0.00| 0.01| -0.07| -0.01|   0| 0.01| 0.05|‚ñÅ‚ñÅ‚ñá‚ñá‚ñÅ |
|CSCO          |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.09|‚ñÅ‚ñá‚ñÅ‚ñÅ‚ñÅ |
|CVX           |         0|             1| 0.00| 0.01| -0.06| -0.01|   0| 0.01| 0.04|‚ñÅ‚ñÅ‚ñá‚ñÖ‚ñÅ |
|DD            |         0|             1| 0.00| 0.01| -0.06| -0.01|   0| 0.01| 0.05|‚ñÅ‚ñÅ‚ñá‚ñÉ‚ñÅ |
|DIS           |         0|             1| 0.00| 0.01| -0.04|  0.00|   0| 0.01| 0.07|‚ñÅ‚ñá‚ñÉ‚ñÅ‚ñÅ |
|GE            |         0|             1| 0.00| 0.01| -0.03| -0.01|   0| 0.01| 0.10|‚ñÉ‚ñá‚ñÅ‚ñÅ‚ñÅ |
|GS            |         0|             1| 0.00| 0.01| -0.03| -0.01|   0| 0.01| 0.03|‚ñÅ‚ñÉ‚ñá‚ñÉ‚ñÅ |
|HD            |         0|             1| 0.00| 0.01| -0.03| -0.01|   0| 0.01| 0.05|‚ñÇ‚ñá‚ñÜ‚ñÅ‚ñÅ |
|IBM           |         0|             1| 0.00| 0.01| -0.07| -0.01|   0| 0.01| 0.04|‚ñÅ‚ñÅ‚ñÇ‚ñá‚ñÅ |
|INTC          |         0|             1| 0.00| 0.02| -0.05| -0.01|   0| 0.01| 0.09|‚ñÅ‚ñá‚ñÖ‚ñÅ‚ñÅ |
|JNJ           |         0|             1| 0.00| 0.01| -0.03|  0.00|   0| 0.01| 0.03|‚ñÅ‚ñÇ‚ñá‚ñÖ‚ñÅ |
|JPM           |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.03|‚ñÅ‚ñÇ‚ñá‚ñÜ‚ñÅ |
|KO            |         0|             1| 0.00| 0.01| -0.06|  0.00|   0| 0.00| 0.04|‚ñÅ‚ñÅ‚ñÉ‚ñá‚ñÅ |
|MCD           |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.05|‚ñÅ‚ñÖ‚ñá‚ñÅ‚ñÅ |
|MMM           |         0|             1| 0.00| 0.01| -0.04|  0.00|   0| 0.01| 0.04|‚ñÅ‚ñÇ‚ñá‚ñÅ‚ñÅ |
|MRK           |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.05|‚ñÅ‚ñÇ‚ñá‚ñÅ‚ñÅ |
|MSFT          |         0|             1| 0.00| 0.01| -0.10| -0.01|   0| 0.01| 0.10|‚ñÅ‚ñÅ‚ñá‚ñÅ‚ñÅ |
|NKE           |         0|             1| 0.00| 0.01| -0.03| -0.01|   0| 0.01| 0.12|‚ñÖ‚ñá‚ñÅ‚ñÅ‚ñÅ |
|PFE           |         0|             1| 0.00| 0.01| -0.03|  0.00|   0| 0.01| 0.04|‚ñÅ‚ñÜ‚ñá‚ñÅ‚ñÅ |
|PG            |         0|             1| 0.00| 0.01| -0.04|  0.00|   0| 0.00| 0.03|‚ñÅ‚ñÅ‚ñá‚ñÉ‚ñÅ |
|TRV           |         0|             1| 0.00| 0.01| -0.04|  0.00|   0| 0.01| 0.03|‚ñÅ‚ñÅ‚ñá‚ñá‚ñÅ |
|UNH           |         0|             1| 0.00| 0.01| -0.03| -0.01|   0| 0.01| 0.05|‚ñÅ‚ñÖ‚ñá‚ñÅ‚ñÅ |
|UTX           |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.03|‚ñÅ‚ñÇ‚ñá‚ñÜ‚ñÇ |
|V             |         0|             1| 0.01| 0.08| -0.05| -0.01|   0| 0.01| 1.38|‚ñá‚ñÅ‚ñÅ‚ñÅ‚ñÅ |
|VZ            |         0|             1| 0.00| 0.01| -0.04|  0.00|   0| 0.00| 0.03|‚ñÅ‚ñÅ‚ñá‚ñá‚ñÅ |
|WMT           |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.05|‚ñÅ‚ñÅ‚ñá‚ñÅ‚ñÅ |
|XOM           |         0|             1| 0.00| 0.01| -0.04| -0.01|   0| 0.01| 0.03|‚ñÅ‚ñÅ‚ñá‚ñÜ‚ñÅ |
- .heatinline[the second line of code provides a useful function to **eyeball** the data.]
- .fatinline[The output describes daily price returns for the 30 components of approximately one year]

]
.panel[
.panel-name[Estimate covariance using `estRMT()`]

.pull-left[
- To fit a covariance matrix we use the pre-defined `estRMT` function

```r
estRMT(R,Q=NA,cutoff = c("max","each"),
              eigenTreat = c("average","delete"),
              numEig = 1,parallel = TRUE)
```

This estimates the covariance matrix most of the default options


```r
model &lt;- estRMT(dow30data, parallel=FALSE)
```
]
.pull-right[   
- This function takes several options which are detailed opposite.
- However, in the simplest case we can pass a timeseries object of asset returns. 
- In such a case we will assume that we know the largest eigenvalue and fit the distribution to the remaining eigenvalues. 
- Values less than the cut-off are replaced with an average value.
]
]
]

---
class:inverse
### Explanation of the `estRMT` function

- `R` xts or matrix of asset returns
- `Q` ratio of rows/size. Can be supplied externally or fit using data
- `cutoff` takes two values max/each. If cut-off is max, Q is fitted and cutoff for eigenvalues is calculated. If cut-off is each, Q is set to row/size. Individual cut-off for each eigenvalue is calculated and used for filtration. 
- `eigenTreat` takes 2 values, average/delete. If average then the noisy  eigenvalues are averaged and each value is replaced by average. If delete then noisy eigenvalues are ignored and the diagonal entries of the correlation matrix are replaced with 1 to make the matrix psd.
- `numEig` number of eigenvalues that are known for variance calculation.
Default is set to 1. If numEig = 0 then variance is assumed to be 1.
- `parallel` boolean to use all cores of a machine.

---
class:middle
# Plot the Marcenko-Pastur estimates
.pull-left.large[
- Once we have fitted a model we can also investigate the fit visually using the `\(\texttt{plot}\)` function. 
- The plot function takes in a fitted model and plots the fitted density overlays on a histogram. 
- It also displays some important fit parameters.
]

.pull-right[

```r
plot(model)
```

![](Lecture-3-denoising-and-detoning_in_Rcode_files/figure-html/rmt-plot-1.png)&lt;!-- --&gt;
]

---
class:middle
# A real world application of the random matrix technique
.pull-left[
- We will now demonstrate the use of RMT with a more elaborate *toy* example. 
- Let us build a custom portfolio stratey using all 30 stocks from the Daily Dow Jones 30 index. We will use `\(\texttt{dow30data}\)` object that contains daily data from 04/02/2014 to 07/10/2015. 

- We will use the `\(\texttt{PortfolioAnalytics}\)` package for building the portfolio and backtest/operationally evaluate the strategy. 

- Let us first construct a custom moment function where covariance is built by denoising using Random Matrix Theory. We assume no third/fourth order effects.
]
.pull-right[

```r
custom.portfolio.moments &lt;- function(R, portfolio) {
  momentargs&lt;-list()
  momentargs$mu&lt;-matrix(as.vector(apply(R,2, "mean")), ncol = 1)
  momentargs$sigma&lt;-estRMT(R, parallel=FALSE)$cov
   momentargs$m3 &lt;- matrix(0, nrow=ncol(R), ncol=ncol(R)^2)
  momentargs$m4 &lt;- matrix(0, nrow=ncol(R), ncol=ncol(R)^3)
  return(momentargs)
}
```
]
---
class:middle
# A real world application of the random matrix technique

- Using the package `PortfolioAnalytics` we will construct a portfolio with the following specification. 
  1. No short sales are allowed. 
  2. All cash needs to be invested at all times. 
  3. Set the objective to maximize the quadratic utility which maximizes returns while controlling for risk. 


```r
library(PortfolioAnalytics)
pspec.lo &lt;- portfolio.spec(assets = colnames(dow30data))
# Specification 1 and 2
pspec.lo &lt;- add.constraint(pspec.lo, type="full_investment")
pspec.lo &lt;- add.constraint(pspec.lo, type="long_only")
# Specification 3
pspec.lo &lt;- add.objective(portfolio=pspec.lo, type="return", name="mean")
pspec.lo &lt;- add.objective(portfolio=pspec.lo, type="risk", name="var")
```

---
class:middle
# A real world application of the random matrix technique

- Now lets backtest our strategy using an ordinary covariance matrix and a covariance matrix build by denoising using Random Matrix theory. 


```r
opt.ordinary &lt;- 
  optimize.portfolio.rebalancing(dow30data, pspec.lo, 
                                 optimize_method="quadprog",
                                 rebalance_on="months", 
                                 training_period=120,
                                 trailing_periods=120)
opt.rmt &lt;- 
  optimize.portfolio.rebalancing(dow30data, pspec.lo, 
                                 optimize_method="quadprog",
                                 momentFUN = "custom.portfolio.moments",
                                 rebalance_on="months", 
                                 training_period=120, 
                                 trailing_periods=120)
```

---
class:middle
# A real world application of the random matrix technique

- We can now extract weights and build cumulative returns using the `\(\texttt{PerformanceAnalytics}\)` package.


```r
ordinary.wts &lt;- na.omit(extractWeights(opt.ordinary))
ordinary &lt;- Return.rebalancing(R=dow30data, weights=ordinary.wts)

rmt.wts &lt;- na.omit(extractWeights(opt.rmt))
rmt &lt;- Return.rebalancing(R=dow30data, weights=rmt.wts)

rmt.strat.rets &lt;- merge.xts(ordinary,rmt)
colnames(rmt.strat.rets) &lt;- c("ordinary", "rmt")
```



---
class:top
### A real world application of the RMT technique
.panelset[
.panel[
.panel-name[Ploting the experimental results]

```r
charts.PerformanceSummary(rmt.strat.rets,wealth.index = T, 
                          colorset = c("red","blue"), 
                          main=paste(c("Comparison of Portflio ",
                                     "Performance using two ",
                                     "different covariance matrices"),
                                     collapse=""), cex.legend = 1.3, 
                          cex.axis = 1.3, legend.loc = "topleft")
```
]
.panel[
.panel-name[Results]
&lt;img src="Lecture-3-denoising-and-detoning_in_Rcode_files/figure-html/plot results1-1.png" width="576" style="display: block; margin: auto;" /&gt;
]
.panel[
.panel-name[Inference]
.large.fancy[
- In the plot below we can see that the cumulative returns generated using our strategy with filtering using Random Matrix Theory are superior to ordinary returns. 
- They are also better with smaller drawdowns (a measure of downside risk of an investment strategy). 
- This suggests that there is value in filtering a large sample covariance matrix before using it for optimizing portfolios.
]
]
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": true,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
(function(time) {
  var d2 = function(number) {
    return ('0' + number).slice(-2); // left-pad 0 to minutes/seconds
  },

  time_format = function(total) {
    var secs = Math.abs(total) / 1000;
    var h = Math.floor(secs / 3600);
    var m = Math.floor(secs % 3600 / 60);
    var s = Math.round(secs % 60);
    var res = d2(m) + ':' + d2(s);
    if (h > 0) res = h + ':' + res;
    return res;  // [hh:]mm:ss
  },

  slide_number_div = function(i) {
    return document.getElementsByClassName('remark-slide-number').item(i);
  },

  current_page_number = function(i) {
    return slide_number_div(i).firstChild.textContent;  // text "i / N"
  };

  var timer = document.createElement('span'); timer.id = 'slide-time-left';
  var time_left = time, k = slideshow.getCurrentSlideIndex(),
      last_page_number = current_page_number(k);

  setInterval(function() {
    time_left = time_left - 1000;
    timer.innerHTML = ' ' + time_format(time_left);
    if (time_left < 0) timer.style.color = 'red';
  }, 1000);

  slide_number_div(k).appendChild(timer);

  slideshow.on('showSlide', function(slide) {
    var i = slide.getSlideIndex(), n = current_page_number(i);
    // reset timer when a new slide is shown and the page number is changed
    if (last_page_number !== n) {
      time_left = time; last_page_number = n;
      timer.innerHTML = ' ' + time_format(time); timer.style.color = null;
    }
    slide_number_div(i).appendChild(timer);
  });
})(120000);
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
